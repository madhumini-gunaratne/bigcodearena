{"uid": "gen_000000", "instruction": "Implement a Python function to find the minimum number of operations required to make all elements in a binary array equal. You are allowed to flip any contiguous subarray of elements (i.e., change 0s to 1s and 1s to 0s) in a single operation. The function should return the minimum number of such operations needed to convert the entire array into all 1s. Consider edge cases such as arrays with all 1s or all 0s. Provide an efficient algorithm and explain how it works.", "category": "problem_solving", "source_seeds": ["ebffd42fc27e44838c26a5453b3ecfbc", "650e51e212c148cfa0b6ce1a702af4a1"], "generation_method": "from_seed"}
{"uid": "gen_000001", "instruction": "Design a function that implements a lock-free queue for producing and consuming messages between threads, ensuring that both operations are thread-safe and efficient without using mutexes or condition variables. The queue should support dynamic resizing and provide a mechanism to detect and handle memory corruption caused by dangling pointers during message processing. The function must include appropriate error handling and provide a performance metric for the average number of operations per second.", "category": "problem_solving", "source_seeds": ["16e6b09503b849d88aaeaa47b9354118", "6d80c55799a24a3c8b8aeb19536f135d"], "generation_method": "from_seed"}
{"uid": "gen_000002", "instruction": "Write a Python function that implements the Two Sum problem with a twist: given a sorted array of integers and a target sum, return all unique pairs of indices (i, j) such that array[i] + array[j] == target and i < j. The function should use a two-pointer technique to achieve O(n log n) time complexity, leveraging the sorted nature of the input to efficiently find valid pairs. The output should be a list of tuples, each containing the indices (i, j) of the pair. Ensure the solution handles edge cases such as no valid pairs or arrays with fewer than two elements. The function must not use nested loops.", "category": "problem_solving", "source_seeds": ["4354f90e6332487c9099408ac48bbb82", "42bcaaa991bc442eafa7e78aaa028b2e"], "generation_method": "from_seed"}
{"uid": "gen_000003", "instruction": "Write a function that simulates a real-time inventory management system for an online marketplace, tracking item availability, order processing, and stock updates. The system should handle multiple concurrent orders, apply real-time stock deductions, and prevent overselling. The function should accept a list of order requests (each containing item ID, quantity, and timestamp), and return a list of processed orders with status (confirmed, rejected, or fulfilled), along with the final inventory state after all updates. Ensure the function accounts for concurrency by using thread-safe operations and includes a mechanism to detect and report potential overselling attempts. Include error handling for invalid inputs such as negative quantities or missing item IDs. Implement the solution in Python. Consider the use of threading and a shared inventory dictionary to simulate concurrent access. Assume the initial inventory is provided as a dictionary mapping item IDs to available quantities. The output should clearly indicate which orders were processed successfully and which were rejected due to insufficient stock. Each order entry should include the original request and the resulting status. The function should also provide a summary of the final inventory and any overselling events detected. (Note: This is a simulation; the system does not need to handle actual marketplace transactions or external APIs.) This question tests knowledge of concurrency, data structures, and real-time system simulation. It emphasizes the importance of thread safety in handling shared resources and designing robust systems for high-throughput environments. The solution should be efficient and clear, with proper error handling and validation. Note: The system must not allow overselling; all attempted overselling should be flagged and reported. Additionally, provide a function that, given a list of order requests and initial inventory, returns the final inventory state, order outcomes, and a list of overselling events. This function should also verify that the total quantity of all items in the final inventory is consistent with the initial state minus the total quantity of successfully processed orders. The integrity of the inventory data must be preserved. The function must ensure that no order is processed if the required quantity exceeds available stock at the time of processing. Time complexity should be reasonable for large input sizes. The solution must account for the order of processing and the impact of concurrent operations. Implement the solution in Python. Do not use external libraries beyond standard library. Your solution should be self-contained and demonstrate a deep understanding of synchronization in concurrent programming. Do not make assumptions about the marketplace's actual operations beyond the simulation described. The goal is to simulate a realistic and complex system that requires careful handling of shared state. You are not required to handle message queuing or external integrations. Focus on the core concurrency and validation logic. The simulation must be accurate and reflect real-world challenges such as race conditions and overselling. The system should detect and report every instance where an order would have caused stock to go negative. The output must include a clearly structured report that can be used to debug or audit the system. Include a detailed error message for invalid inputs. Consider the implications of thread safety and the need for mutual exclusion when accessing shared inventory. The solution should be modular and well-documented in code comments, even if not explicitly required. Avoid global variables; use local variables and pass data as parameters. The solution should handle edge cases such as zero stock, partial fulfillment, and multiple overlapping orders for the same item. The function must return the final inventory state, processed orders with status, and a list of overselling events. It should also verify the final inventory total matches the expected total. Failure to do so indicates a bug in the simulation. This is a comprehensive test of understanding real-time systems, thread safety, and data consistency. Do not modify the initial inventory; only update it during processing. All order status updates should be based on the state at the time of processing. The simulation should reflect real-world constraints such as stock limits and order rejection policies. The function should be robust and fail gracefully for invalid inputs. Output the result as a dictionary with keys: 'final_inventory', 'processed_orders', and 'overselling_events'. The processed_orders list should contain entries with keys: 'request', 'status', 'timestamp', and 'item_id'. The 'status' can be 'confirmed', 'rejected', or 'fulfilled'. Ensure that the total quantity of all items in the final inventory is exactly equal to the initial inventory total minus the sum of all successfully processed orders (excluding rejected ones). This is a critical integrity check. The function must not allow stock to go negative. Every operation must respect the current stock level. The solution should be efficient and maintainable, avoiding unnecessary locking or performance degradation. The function must return a valid result even if no orders are processed. Implement the solution in Python. Do not use external libraries beyond standard library. Your solution should be self-contained and demonstrate a deep understanding of synchronization in concurrent programming. Note: This is a simulation; the system does not need to handle actual marketplace transactions or external APIs. The goal is to simulate a realistic and complex system that requires careful handling of shared state. The simulation must be accurate and reflect real-world challenges such as race conditions and overselling. The system should detect and report every instance where an order would have caused stock to go negative. The output must include a clearly structured report that can be used to debug or audit the solution. Consider the implications of thread safety and the need for mutual exclusion when accessing shared inventory. The solution should handle edge cases such as zero stock, partial fulfillment, and multiple overlapping orders for the same item. The function must return the final inventory state, processed orders with status, and a list of overselling events. It should also verify the final inventory total matches the expected total. Failure to do so indicates a bug in the simulation. This is a comprehensive test of understanding real-time systems, thread safety, and data consistency. Do not modify the initial inventory; only update it during processing. All order status updates should be based on the state at the time of processing. The simulation should reflect real-world constraints such as stock limits and order rejection policies. The function should be robust and fail gracefully for invalid inputs. Output the result as a dictionary with keys: 'final_inventory', 'processed_orders', and 'overselling_events'. The processed_orders list should contain entries with keys: 'request', 'status', 'timestamp', and 'item_id'. The 'status' can be 'confirmed', 'rejected', or 'fulfilled'. Ensure that the total quantity of all items in the final inventory is exactly equal to the initial inventory total minus the sum of all successfully processed orders (excluding rejected ones). This is a critical integrity check. The function must not allow stock to go negative. Every operation must respect the current stock level. The solution should be efficient and maintainable, avoiding unnecessary locking or performance degradation. The function must return a valid result even if no orders are processed. Implement the solution in Python. Do not use external libraries beyond standard library. Your solution should be self-contained and demonstrate a deep understanding of synchronization in concurrent programming. Note: This is a simulation; the system does not need to handle actual marketplace transactions or external APIs. The goal is to simulate a realistic and complex system that requires careful handling of shared state. The simulation must be accurate and reflect real-world challenges such as race conditions and overselling. The system should detect and report every instance where an order would have caused stock to go negative. The output must include a clearly structured report that can be used to debug or audit the solution. Consider the implications of thread safety and the need for mutual exclusion when accessing shared inventory. The solution should handle edge cases such as zero stock, partial fulfillment, and multiple overlapping orders for the same item. The function must return the final inventory state, processed orders with status, and a list of overselling events. It should also verify the final inventory total matches the expected total. Failure to do so indicates a bug in the simulation. This is a comprehensive test of understanding real-time systems, thread safety, and data consistency. Do not modify the initial inventory; only update it during processing. All order status updates should be based on the state at the time of processing. The simulation should reflect real-world constraints such as stock limits and order rejection policies. The function should be robust and fail gracefully for invalid inputs. Output the result as a dictionary with keys: 'final_inventory', 'processed_orders', and 'overselling_events'. The processed_orders list should contain entries with keys: 'request', 'status', 'timestamp', and 'item_id'. The 'status' can be 'confirmed', 'rejected', or 'fulfilled'. Ensure that the total quantity of all items in the final inventory is exactly equal to the initial inventory total minus the sum of all successfully processed orders (excluding rejected ones). This is a critical integrity check. The function must not allow stock to go negative. Every operation must respect the current stock level. The solution should be efficient and maintainable, avoiding unnecessary locking or performance degradation. The function must return a valid result even if no orders are processed. Implement the solution in Python. Do not use external libraries beyond standard library. Your solution should be self-contained and demonstrate a deep understanding of synchronization in concurrent programming. Note: This is a simulation; the system does not need to handle actual marketplace transactions or external APIs. The goal is to simulate a realistic and complex system that requires careful handling of shared state. The simulation must be accurate and reflect real-world challenges such as race conditions and overselling. The system should detect and report every instance where an order would have caused stock to go negative. The output must include a clearly structured report that can be used to debug or audit the solution. Consider the implications of thread safety and the need for mutual exclusion when accessing shared inventory. The solution should handle edge cases such as zero stock, partial fulfillment, and multiple overlapping orders for the same item. The function must return the final inventory state, processed orders with status, and a list of overselling events. It should also verify the final inventory total matches the expected total. Failure to do so indicates a bug in the simulation. This is", "category": "problem_solving", "source_seeds": ["5b170842adf3433d8cd86c3df629f44b", "d245ec19b7f84605803b6de31db7caf2"], "generation_method": "from_seed"}
{"uid": "gen_000004", "instruction": "Write a Python function to find the minimum number of operations required to make all elements in a binary array equal by flipping bits. The function should take a list of integers (0s and 1s) and return the minimum number of bit flips needed. You may assume that the array size is at most 1000 and that the final value of all elements must be either 0 or 1. Use a greedy approach to solve this efficiently.", "category": "problem_solving", "source_seeds": ["8765b06fb9bb410087410ebda9f7b98c", "b3846b5c113e41a394ec511f7f656811"], "generation_method": "from_seed"}
{"uid": "gen_000005", "instruction": "You are given a grid of size m x n, initially filled with water. You are given a sequence of operations, each of which adds land at a specific cell (row, col). After each operation, you must compute the number of connected components of land, where land cells are considered connected if they are adjacent horizontally or vertically (up, down, left, right). Return the number of islands after each operation. Design a solution that efficiently handles the operations and maintains the count of islands as new land is added. Consider how to optimize the counting process to avoid recalculating the entire connectivity from scratch after each operation.  \nNote: An island is a maximal group of connected land cells. Two land cells are connected if they share an edge (not a corner).  \nFor example, if the grid is 3x3 and the operations are: addLand(0,0), addLand(0,1), addLand(1,0), then after the first operation there is 1 island, after the second operation there is still 1 island, after the third operation there is still 1 island (all three are connected). After addLand(2,2), if it's isolated, there would be 2 islands.  \nThis problem is similar to Union-Find with dynamic connectivity, where we track how many connected components exist as new land cells are added. Your solution should be efficient in both time and space.  \nYou may assume that the operations are performed sequentially, and the grid remains at the same size throughout.  \nReturn a vector of integers representing the number of islands after each operation.  \nInput:  \nOutput:  \nConstraints:  \nYou may use any data structures or algorithms that are appropriate to solve this efficiently.  \nBonus: Can you design a solution that avoids recomputing connectivity from scratch each time and instead updates the island count incrementally?  \nNote: This is not a simple pathfinding or flood-fill problem. You are expected to maintain connectivity information dynamically and update the island count efficiently.  \nExample:  \nm = 3, n = 3, operations = [(0,0), (0,1), (1,0), (2,2)]  \n\u2192 Output: [1, 1, 1, 2]  \n(First three operations form a connected component. The fourth operation is isolated, forming a new island.)  \nYour solution should be suitable for integration into a larger application that processes a sequence of updates.  \nDesign and implement a function to solve this problem. Do not provide code in your response. Instead, describe the problem clearly and fully.  \nThe solution must be scalable and maintainable. Describe how you would approach the problem, including the data structures and reasoning behind your design choices.  \nYou may assume that all operations are performed in the given order and that the grid dimensions are fixed. The solution must be efficient enough to handle large inputs within reasonable time and memory.  \nConsider edge cases such as an empty grid, isolated cells, or when all cells are land.  \nThis problem emphasizes the importance of efficient dynamic updates in real-time systems. Your design should reflect an understanding of union-find and incremental updates.  \nIt is not sufficient to simply perform a flood-fill after each operation. You must provide a mechanism to update the island count without full recalculations.  \nThe final output must be a vector of integers representing the number of islands after each operation in sequence.  \nAdditionally, consider whether the complexity of your solution scales well with the number of operations.  \nWhat is the time and space complexity of your proposed solution?  \nWhat data structures would you use, and why?  \nHow does your solution handle the case when a new land cell connects to an existing island (reducing the total count by 1) or when it forms a new island (increasing by 1)?  \nHow do you ensure that the solution works correctly in all edge cases?  \nProvide a detailed explanation of your design and the reasoning behind it.  \nYou are expected to write a complete, production-ready solution to this problem.  \nDo not include any trivial or inefficient approaches.  \nThis is a core data structures and algorithm problem that tests understanding of dynamic connectivity and incremental updates.  \nYou may use standard libraries, but your design should focus on performance and scalability.  \nThis is a practical problem that could be applied in real-time applications such as terrain generation or real-time map updates.  \nYou are expected to provide a clear, well-structured response that demonstrates deep understanding of the problem and its solution.  \nAfter solving the problem, verify your solution with the example provided. Ensure it matches the expected output.  \nThe problem requires careful thought about data structures and algorithms to avoid exponential time complexity.  \nYou should consider the impact of each operation on the connectivity graph and how to maintain the total count efficiently.  \nYour solution must handle up to 10,000 operations on a 1000x1000 grid efficiently.  \nThis is a challenging and realistic problem in systems programming and real-time data processing.  \nDo not make assumptions about external tools or libraries. Solve it directly with core programming concepts.  \nThe solution should be designed for scalability and real-world applicability.  \nYou are not required to write code. Instead, focus on the problem formulation and the design of the solution.  \nDescribe how you would approach the problem and what key decisions you would make in your design.  \nThis question is designed to assess deep understanding of dynamic connectivity and incremental updates in large-scale systems.  \nIt is not about brute force or na\u00efve approaches. It is about intelligent, scalable design.  \nFinal output: A complete, clear, and self-contained problem statement with all necessary details and constraints.  \nYou must output exactly one question, as specified.  \nDo not include any markdown, headers, or additional text.  \nThe question must be ready to be used as-is in a coding assessment.  \nNo extra text, no explanations, no metadata. Just the clean, clear question text.  \nYou are expected to produce a high-quality, production-grade problem.  \nEnsure the problem is challenging but solvable within the constraints.  \nDesign a solution that balances technical depth with practical implementation.  \nFocus on the core algorithmic challenge and not on implementation details.  \nThe problem should test both algorithmic understanding and system-level thinking.  \nYou must ensure that the problem is unique and not a rephrasing of existing ones.  \nIt should be closely related in style and difficulty to the provided examples.  \nThe final output must be a single, clean, and complete question.  \nThis is your final output.  \nDo not repeat or rephrase.  \nOnly output the question.  \nOnly output one question.  \nOnly output the question text.  \nThe question should match the style, length, and complexity of the provided examples.  \nThe output must be exactly one question.  \nNo additional content.  \nFinal output begins now.  \nYou are given a grid of size m x n, initially filled with water. You are given a sequence of operations, each of which adds land at a specific cell (row, col). After each operation, you must compute the number of connected components of land, where land cells are considered connected if they are adjacent horizontally or vertically (up, down, left, right). Return the number of islands after each operation. Design a solution that efficiently handles the operations and maintains the count of islands as new land is added. Consider how to optimize the counting process to avoid recalculating the entire connectivity from scratch after each operation.  \nNote: An island is a maximal group of connected land cells. Two land cells are connected if they share an edge (not a corner).  \nFor example, if the grid is 3x3 and the operations are: addLand(0,0), addLand(0,1), addLand(1,0), then after the first operation there is 1 island, after the second operation there is still 1 island, after the third operation there is still 1 island (all three are connected). After addLand(2,2), if it's isolated, there would be 2 islands.  \nThis problem is similar to Union-Find with dynamic connectivity, where we track how many connected components exist as new land cells are added. Your solution should be efficient in both time and space.  \nYou may assume that the operations are performed sequentially, and the grid remains at the same size throughout.  \nReturn a vector of integers representing the number of islands after each operation.  \nInput:  \nOutput:  \nConstraints:  \nYou may use any data structures or algorithms that are appropriate to solve this efficiently.  \nBonus: Can you design a solution that avoids recomputing connectivity from scratch each time and instead updates the island count incrementally?  \nNote: This is not a simple path", "category": "problem_solving", "source_seeds": ["56d9db68e51f4fd0bba0535850e0855c", "e069250053024b3baacbbd5cdfdd2cfc"], "generation_method": "from_seed"}
{"uid": "gen_000006", "instruction": "You are given a list of N integers representing the heights of a series of buildings. A rainwater trap is a position where water can be collected due to the presence of higher buildings on both sides. Calculate the total volume of water that can be trapped between these buildings. Assume the ground is level and the buildings are aligned in a straight line. For example, if the building heights are [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2], the water trapped at each position can be determined by the minimum of the maximum heights to the left and right, minus the height of the current building. Return the total volume of water trapped.**", "category": "problem_solving", "source_seeds": ["5c1356263ead4bbbaa55442e9db6373d", "b45e87c52233464893a186c39e6fe9a4"], "generation_method": "from_seed"}
{"uid": "gen_000007", "instruction": "Implement a Python algorithm to find the shortest path in a weighted directed graph using Dijkstra's algorithm. Ensure the solution efficiently handles sparse graphs and large-scale inputs, and includes mechanisms to detect and handle negative edge weights appropriately. Explore optimization techniques for reducing memory usage and improving runtime performance.", "category": "problem_solving", "source_seeds": ["5a5fdfe0cdd3406faa1fb620bd9becbb", "6d29db23cf7442c39759f09c0034d5a3"], "generation_method": "from_seed"}
{"uid": "gen_000008", "instruction": "Design a secure and efficient password manager in C that stores encrypted passwords using AES-256-CBC, allows users to add, modify, and delete entries, and supports key derivation via PBKDF2 with a salt and iteration count, while ensuring data integrity through HMAC-SHA256.", "category": "problem_solving", "source_seeds": ["fa0f8459246744b39ed472b71cf77e3b", "c81b2128ddb24a16a3fd75514f284f51"], "generation_method": "from_seed"}
{"uid": "gen_000009", "instruction": "Implement a lock-free queue using a linked list with atomic operations to support concurrent producer and consumer access, featuring a circular buffer design to minimize memory overhead and a wait-free approach for consumer operations. The queue must support bounded capacity, efficient enqueue and dequeue operations, and provide a mechanism to detect and handle full/empty conditions without blocking, using compare-and-swap for thread safety. Additionally, include a memory reclamation strategy for stale nodes to prevent memory leaks.", "category": "problem_solving", "source_seeds": ["0bc2fb1fbb504474b65cd6195aff29be", "b8994528c5914ab5951ca47d07f1788e"], "generation_method": "from_seed"}
