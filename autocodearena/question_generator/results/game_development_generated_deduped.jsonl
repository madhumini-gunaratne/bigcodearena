{"uid": "gen_000000", "instruction": "Implement a standalone Python script using PyGame to simulate a procedurally generated maze with recursive backtracking algorithm. The maze must be generated on a 2D grid of fixed size (e.g., 20x20), and walls must be properly drawn with a consistent tile-based rendering system. Include player movement controls (up/down/left/right) that allow the player to navigate through the maze, and ensure the player cannot walk through walls. Add a simple win condition when the player reaches the predefined exit point at the bottom-right corner of the maze. The script should not call any external libraries or APIs. All rendering and logic must be self-contained. The maze should be generated only once at startup, and the player's position should be updated in real-time as they move. Use a fixed grid size and consistent tile dimensions for visual clarity. Implement basic collision detection to prevent the player from moving into walls. Do not use any pre-built maze generation libraries. Use only standard PyGame functionalities. The maze generation and player navigation must be fully implemented from scratch. Do not use external resources or external data. All logic and rendering must be self-contained within a single Python file. The maze generation should be deterministic, so that the same input produces the same maze layout each time. The player's movement should be limited to adjacent cells and must not allow diagonal movement. The exit point should be placed at the bottom-right corner and must be clearly marked with a distinct visual element. The script must render the maze and player position in real-time. The exit condition should trigger a \"Maze Solved!\" message that displays on screen for a brief duration before the game ends. Implement a clean and readable code structure with proper comments for each major component.\nWe are creating a new question that matches the style and complexity of the provided examples.\nKey observations from the sample questions:\nWe are to create a question that is:\nLet's consider a new scenario: a procedural generation of a 2D city with buildings and roads using a cellular automaton approach.\nNew question:\nImplement a standalone Python script using PyGame to simulate a procedurally generated 2D city layout using a cellular automaton algorithm. The city must be generated on a 30x30 grid where each cell represents a block. Use a simple cellular automaton rule (e.g., a 3x3 Moore neighborhood) to generate buildings, roads, and open spaces. A cell becomes a building if at least 3 of its 8 neighbors are buildings, and becomes open otherwise. Apply this rule over multiple iterations to create a natural-looking urban pattern. Render the city using a tile-based system where buildings are represented by solid rectangles and open spaces by a blank background. Include player movement controls (up/down/left/right) that allow the player to navigate the city, and ensure the player cannot walk through buildings. Add a simple win condition when the player reaches the predefined exit located at the center of the bottom row. The script should not call any external libraries or APIs. All rendering and logic must be self-contained. The city generation should be deterministic, so that the same input produces the same layout each time. The player's movement should be limited to adjacent cells and must not allow diagonal movement. The exit point should be clearly marked with a distinct visual element. The script must render the city and player position in real-time. Implement basic collision detection to prevent the player from moving into buildings. Do not use any pre-built city generation libraries. Use only standard PyGame functionalities. The city generation and player navigation must be fully implemented from scratch. Do not use external resources or external data. All logic and rendering must be self-contained within a single Python file. The city generation should be deterministic, so that the same input produces the same layout each time. The player's movement should be limited to adjacent cells and must not allow diagonal movement. The exit condition should trigger a \"City Reached!\" message that displays on screen for a brief duration before the game ends. Implement a clean and readable code structure with proper comments for each major component.\nNote: We can see that we are repeating the structure. Let's make it slightly more concise while preserving the required elements and ensuring uniqueness.\nActually, we must avoid repetition. Let's make it more focused and slightly different in core idea but still within the same domain.\nAlternative idea: Instead of a city, how about a procedural terrain with elevation and water? But that might go beyond.\nLet's go back: we already have terrain generation with noise and fractals, and maze with recursive backtracking.\nWe could create a procedural cave system using a spanning tree algorithm on a grid.\nBut the sample includes a maze with recursive backtracking, so we must avoid that.\nSo let's do something different: procedural generation of a forest with trees using a perlin-like noise in a grid? But that would be similar to the terrain generation.\nWe need a new unique idea that is still within the same style.\nHow about: a procedural generation of a 2D puzzle maze using a depth-first search? But that's similar to the recursive backtracking.\nAlternatively, a grid-based simulation of a fire spreading using a cellular automaton?\nYes! That would be novel, within the same domain (procedural generation, real-time interaction), and not covered in the samples.\nFinal choice: Simulate a fire spreading in a grid using a cellular automaton, with real-time player interaction.\nBut the problem asks for a \"maze\" with movement. How about a fire maze?\nActually, let's reframe: create a simulation where the player must navigate through a grid, and fire spreads from a starting point in each time step, and the player must avoid burning tiles.\nThat introduces a dynamic element not present in the maze or terrain examples.\nBut the original question about maze with player movement is already present \u2014 we need to avoid rephrasing that.\nWait: the sample has a procedural maze generation with player movement. We are to create a different one.\nSo we can create a different procedural generation with dynamic time-based changes.\nFinal decision: Create a simulation of a fire spreading in a 2D grid generated via cellular automaton, with a player who can move and must avoid burning tiles. The player starts at the top-left, and fire starts at the top-right. The fire spreads one step per time unit to adjacent cells. The player moves one cell per key press. The fire spreads independently of the player. The grid is 20x20, with each cell being either open (with 50% chance of having a wall) or open. After generating the initial layout, apply a cellular automaton rule (fire spreads to adjacent open cells) in each time step. The player loses if they step on a burning cell. The game ends when the player reaches the exit at the bottom-left. The script must be self-contained and use only PyGame.\nBut this is getting complex. Let's go back to the examples: the examples are about procedural generation, real-time player movement, and deterministic behavior.\nLet's keep it within the same scope but with a different algorithm and domain.\nNew idea: Generate a 2D dungeon using a random walk algorithm (or a spanning tree with random walk), but that's similar to maze.\nAfter review, the most distinct and unique that fits the style is:\nImplement a standalone Python script using PyGame to simulate a procedurally generated forest with trees and pathways using a Perlin noise-based algorithm. The forest must be generated on a 30x30 grid where each cell's value is derived from noise at that position. A cell becomes a tree if the noise value is above a threshold (e.g., 0.6), otherwise it's open ground. Paths are formed by connecting adjacent open ground cells using a simple pathfinding algorithm (like A* or Dijkstra) to create traversable routes. The player must navigate the forest, moving only through open ground and along generated pathways. The player starts at the top-left corner and must reach the exit at the bottom-right corner. The script should not call any external libraries or APIs. All rendering and logic must be self-contained. The forest generation should be deterministic, so that the same input produces the same layout each time. The player's movement should be limited to adjacent cells and must not allow diagonal movement. The script must render the forest and player position in real-time. Implement basic collision detection to prevent the player from stepping on trees. When the player reaches the exit, display a \"Forest Clear!\" message that lasts for 2 seconds before the game ends. All logic and rendering must be implemented from scratch using only standard PyGame functionalities. The script must not use any external resources or pre-built generation libraries. The noise function must be implemented manually using a simple 2D noise algorithm (e.g., using integer coordinates and trigonometric functions). The generated forest and pathways must be visually distinct, with trees as solid blocks and open ground as a gradient background. Implement a clean and readable code structure with proper comments for each major component.\nBut the sample question about terrain generation with noise already exists.\nWe must avoid noise and fractal similarity.\nBack to cellular automaton for fire? Let's do that with a clear structure.\nFinal choice:\nImplement a standalone Python script using PyGame to simulate a cellular automaton-based infection spread in a 20x20 grid. The", "category": "game_development", "source_seeds": ["2a41969c442642d098a81b9dffbaab3d", "ae149af364bc484a9e4dd820691efe01"], "generation_method": "from_seed"}
{"uid": "gen_000001", "instruction": "Develop a Java-based real-time traffic management system for a smart city. The application should simulate traffic lights at multiple intersections using a decentralized control algorithm where each intersection manages its own traffic light cycle independently but coordinates with neighboring intersections to avoid congestion. Each traffic light should have a state (red, yellow, green) and a duration for each state. Implement a visual dashboard that displays the current state of all traffic lights, real-time vehicle flow data, and congestion levels. Add functionality to simulate random vehicle arrivals at intersections, where vehicles choose routes based on traffic conditions, and update the system in real time. Include a logging mechanism to record traffic events and allow users to replay a simulation scenario with adjustable time steps and pause/resume controls. The system should also support a mode where traffic lights can be manually overridden to test emergency scenarios such as accidents or road closures. Each light's transition should follow a fixed timing pattern with slight variations to create realistic behavior, and the overall simulation should run efficiently even with a large number of intersections.", "category": "game_development", "source_seeds": ["43af8ab5a9fb4c47b8dd2ffa68ad1a46", "aa529ab44813453db9b0f70b765b2db4"], "generation_method": "from_seed"}
{"uid": "gen_000002", "instruction": "Write a Python script that creates a PyGame environment where players navigate a lunar surface by collecting oxygen bottles and avoiding temperature hazards.", "category": "game_development", "source_seeds": ["791e29d9d5204a6e9a7b9756295c781b", "cc62d22a794246ceab79b7062478c29a"], "generation_method": "from_seed"}
{"uid": "gen_000003", "instruction": "Write a Python script that creates a PyGame-based space invaders game with dynamically generated enemy patterns and collision detection using physics-based movement.", "category": "game_development", "source_seeds": ["9aa2725cfc604c67b4094c446b21f1b2", "8c43ce69c82348929e07448190a5f0b1"], "generation_method": "from_seed"}
{"uid": "gen_000004", "instruction": "Implement a blockchain-based voting system where users can submit votes, and votes are cryptographically secured and immutable. Include functionality to verify vote integrity and detect tampering. Use JavaScript to simulate the core blockchain structure and provide a method to add new votes with timestamp and digital signatures.  \n**Note**: The question should reflect the same creative, application-driven style as the original examples, combining real-world relevance with technical depth. The problem should be engaging and practical, requiring implementation of core programming concepts in a novel scenario.  \n**Task**: Design a **Coding Assessment Question** that matches the style of provided examples.  \n**Objective**: Analyze the provided sample questions and create an additional question that:  \n**Guidelines**  \n### Question Style  \n### Question Length  \n### Difficulty Level  \n### Topic Alignment  \n### Question Uniqueness  \n## Output Format  \nOutput **one new question only**.  \nImplement a blockchain-based voting system where users can submit votes, and votes are cryptographically secured and immutable. Include functionality to verify vote integrity and detect tampering. Use JavaScript to simulate the core blockchain structure and provide a method to add new votes with timestamp and digital signatures.  \n**Note**: The question should reflect the same creative, application-driven style as the original examples, combining real-world relevance with technical depth. The problem should be engaging and practical, requiring implementation of core programming concepts in a novel scenario.  \n**Task**: Design a **Coding Assessment Question** that matches the style of provided examples.  \n**Objective**: Analyze the provided sample questions and create an additional question that:  \n**Guidelines**  \n### Question Style  \n### Question Length  \n### Difficulty Level  \n### Topic Alignment  \n### Question Uniqueness  \n## Output Format  \nOutput **one new question only**.  \nImplement a blockchain-based voting system where users can submit votes, and votes are cryptographically secured and immutable. Include functionality to verify vote integrity and detect tampering. Use JavaScript to simulate the core blockchain structure and provide a method to add new votes with timestamp and digital signatures.  \n**Note**: The question should reflect the same creative, application-driven style as the original examples, combining real-world relevance with technical depth. The problem should be engaging and practical, requiring implementation of core programming concepts in a novel scenario.  \n**Task**: Design a **Coding Assessment Question** that matches the style of provided examples.  \n**Objective**: Analyze the provided sample questions and create an additional question that:  \n**Guidelines**  \n### Question Style  \n### Question Length  \n### Difficulty Level  \n### Topic Alignment  \n### Question Uniqueness  \n## Output Format  \nOutput **one new question only**.  \nImplement a blockchain-based voting system where users can submit votes, and votes are cryptographically secured and immutable. Include functionality to verify vote integrity and detect tampering. Use JavaScript to simulate the core blockchain structure and provide a method to add new votes with timestamp and digital signatures.  \n**Note**: The question should reflect the same creative, application-driven style as the original examples, combining real-world relevance with technical depth. The problem should be engaging and practical, requiring implementation of core programming concepts in a novel scenario.  \n**Task**: Design a **Coding Assessment Question** that matches the style of provided examples.  \n**Objective**: Analyze the provided sample questions and create an additional question that:  \n**Guidelines**  \n### Question Style  \n### Question Length  \n### Difficulty Level  \n### Topic Alignment  \n### Question Uniqueness  \n## Output Format  \nOutput **one new question only**.  \nImplement a blockchain-based voting system where users can submit votes, and votes are cryptographically secured and immutable. Include functionality to verify vote integrity and detect tampering. Use JavaScript to simulate the core blockchain structure and provide a method to add new votes with timestamp and digital signatures.  \n**Note**: The question should reflect the same creative, application-driven style as the original examples, combining real-world relevance with technical depth. The problem should be engaging and practical, requiring implementation of core programming concepts in a novel scenario.  \n**Task**: Design a **Coding Assessment Question** that matches the style of provided examples.  \n**Objective**: Analyze the provided sample questions and create an additional question that:  \n**Guidelines**  \n### Question Style  \n### Question Length  \n- Ensure your new question is of **com", "category": "game_development", "source_seeds": ["646edd9eec7f40ed8d1d1ed47291f37e", "c5923b8d3d614b718ff4e31f06863e58"], "generation_method": "from_seed"}
{"uid": "gen_000005", "instruction": "Simulate a fleet of 50 autonomous robots navigating a dynamic warehouse environment, where each robot must pick up items from designated zones, deliver them to assigned locations, and avoid collisions with both static obstacles and moving agents. The robots must communicate via a decentralized consensus protocol to coordinate pickup and delivery schedules, while minimizing total travel time and energy consumption. Implement the simulation using Python with real-time visual feedback.", "category": "game_development", "source_seeds": ["f1fd32f45f204ecdacf7d8ebf0ded952", "231e7f596b0d45d8850e6e5765412027"], "generation_method": "from_seed"}
{"uid": "gen_000006", "instruction": "Create a Python-based simulation of a sound-emitting robot navigating a grid-based maze, where the robot emits sound pulses to detect walls and obstacles. The robot must determine its position and direction based on the time it takes for echoes to return. The environment includes reflective surfaces that cause sound to bounce, and absorptive materials that reduce echo strength. Implement a sensor system that accounts for sound travel time, absorption, and reflection, allowing the robot to update its position and orientation in real-time. Include a pathfinding algorithm that enables the robot to move toward the exit while avoiding dead ends and obstacles detected through sonar feedback. The simulation should support dynamic maze changes, such as walls that can be temporarily removed or reinforced, based on environmental conditions.", "category": "game_development", "source_seeds": ["81df01a765ee40f68a55b19f502b2fb7", "d016a6ad63ef422490364657cae9e44e"], "generation_method": "from_seed"}
{"uid": "gen_000007", "instruction": "Write a Python script that creates a PyGame \"neon cybernetic\" survival game with AI enemies that adapt their behavior based on player movement patterns.", "category": "game_development", "source_seeds": ["6eed699c87164f2c99d8c4a0913e263d", "197d83e0bfd24391894a025771f70e96"], "generation_method": "from_seed"}
{"uid": "gen_000008", "instruction": "design and implement a strategy game titled \"Realm Rift\". In this game, players must manage three distinct resources\u2014stamina, magic, and food\u2014across a dynamic terrain with evolving environmental conditions. The game board is a 10x10 grid where each cell represents a biome with unique properties (e.g., forests, deserts, mountains) that affect resource generation and consumption. Players place units on the grid and assign them to different actions such as farming, mining, or spellcasting, each consuming one of the three resources. Over time, environmental conditions change (e.g., storms, droughts, or floods) that alter resource availability and increase or decrease unit efficiency. Your task includes generating a randomized terrain map, dynamically updating resource flows based on environmental events, and implementing a turn-based system where players make decisions on resource allocation. You must also include logic to prevent resource depletion and enforce rules that limit the number of units per biome. Additionally, provide visual feedback by animating resource fluctuations and displaying real-time resource levels during gameplay.", "category": "game_development", "source_seeds": ["197d83e0bfd24391894a025771f70e96", "4a3e3ef29fda4e8baaac35338d62052a"], "generation_method": "from_seed"}
{"uid": "gen_000009", "instruction": "Build a physics-based bridge simulation where users design a bridge structure using different materials and beam configurations. The system should calculate the maximum load capacity based on the material strength, beam thickness, and span length. When a load is applied, the simulation should visually indicate stress distribution across the beams and flag if the bridge will collapse under the load. Include options to adjust material properties and structural geometry to optimize stability and strength. The simulation must handle dynamic load testing and provide real-time feedback on structural integrity.  \n**Note**: Ensure the simulation includes a fail-safe mechanism that detects when the maximum stress exceeds the material yield point.  \n**Note**: The load distribution should follow the principles of statics, where shear forces and bending moments are calculated using standard engineering formulas.  \n**Note**: The visualization should highlight regions of high stress with color gradients.  \n**Note**: The simulation should validate user inputs to prevent invalid configurations, such as negative dimensions or unsupported combinations.  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n**End of Output**  \n---", "category": "game_development", "source_seeds": ["b776d7a93cb342349eb9f6480c92a5b3", "107493f9b95e4c1cbe33d758935e241a"], "generation_method": "from_seed"}
